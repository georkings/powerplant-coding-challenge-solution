# powerplant-challenge/app/core/merit_order_solver.py

from app.models.data_models import InputPayload, Fuels, Powerplant, ProductionPlanItem

# --- Constants ---
GAS_CO2_EMISSION_FACTOR = 0.3  # tons of CO2 per MWh generated by gas-fired plant

def calculate_mwh_cost(plant: Powerplant, fuels: Fuels) -> float:
    """Calculates the cost (â‚¬/MWh) for powerplants."""
    fuel_price = 0.0
    co2_mwh_cost = 0.0

    if plant.type == "gasfired":
        fuel_price = fuels.gas_euro_per_mwh
        co2_mwh_cost = GAS_CO2_EMISSION_FACTOR * fuels.co2_euro_per_ton

    elif plant.type == "turbojet":
        fuel_price = fuels.kerosine_euro_per_mwh

    elif plant.type == "windturbine":
        return 0.0  # Wind is zero cost

    base_cost = fuel_price / plant.efficiency
    return base_cost + co2_mwh_cost

def calculate_production_plan(payload: InputPayload) -> list[ProductionPlanItem]:
    """
    Implements a greedy merit-order algorithm to determine power production.
    """
    load_remaining = payload.load
    production_plan = []
    total_max_capacity = 0
    
    # 1. Calculate MWh Costs for each Plant
    
    # Store plant data with calculated costs for sorting
    merit_list = []
    
    for plant in payload.powerplants:
        cost = calculate_mwh_cost(plant, payload.fuels)

        pmax_available = plant.pmax
        if plant.type == "windturbine":
            # Available wind power
            pmax_available *= payload.fuels.wind_percentage / 100.0

        total_max_capacity += pmax_available

        merit_list.append({
            "plant": plant,
            "pmax_available": pmax_available,
            "cost": cost,
            "production": 0.0  # Initial production
        })

    if payload.load > total_max_capacity:
        raise ValueError(
            f"Requested load ({payload.load} MWh) exceeds the total maximum generation capacity of all power plants ({total_max_capacity:.1f} MWh)."
        )

    # 2. Sort Fuel Plants by Merit Order (Cost)
    merit_list.sort(key=lambda x: x["cost"])
    
    # 3. Greedy Dispatch of Fuel Plants
    
    # Track units that are turned on (committed)
    committed_units = []

    for item in merit_list:
        plant = item["plant"]

        if load_remaining < 0.1:
            break

        p_min = plant.pmin
        p_pmax_available = item["pmax_available"]

        if load_remaining >= p_min:
            # Dispatch the plant: either fill the remaining load or run at Pmax
            p_dispatch = min(load_remaining, p_pmax_available)
            item["production"] = round(p_dispatch, 1)
            load_remaining -= item["production"]
            committed_units.append(item)
        else:
            # Load_remaining < Pmin.
            # For this solution we choose to skip this plant and try the next ones to see if
            # the load can be fully committed.
            pass

    # 4. Final Adjustment (If load is still remaining, and no plants left)

    # If load is still remaining after all merit-order plants have been considered:
    # This implies the load must be met by committing the cheapest skipped unit at its Pmin,
    # and then adjusting production from other committed units.
    if load_remaining >= 0.1:
        # Find cheapest skipped unit (P_target)
        cheapest_skipped_plant = None
        for item in merit_list:
            if item["plant"].type != "windturbine" and item["production"] == 0.0:
                cheapest_skipped_plant = item
                break

        if cheapest_skipped_plant is not None:
            p_min_target = cheapest_skipped_plant["plant"].pmin

            # Calculate Oversupply
            oversupply_S = p_min_target - load_remaining

            # Commit P_target at Pmin
            cheapest_skipped_plant["production"] = round(p_min_target, 1)

            # Compensate Oversupply (reduce production of committed units)
            # Iterate backwards through committed units (most expensive first)
            committed_units.reverse()

            for item in committed_units:
                if oversupply_S <= 0:
                    break

                plant = item["plant"]

                # Max reduction possible without violating Pmin
                max_reduction = item["production"] - plant.pmin

                reduction_applied = round(min(max_reduction, oversupply_S), 1)

                item["production"] = item["production"] - reduction_applied
                oversupply_S -= reduction_applied

        else:
            # This case must not happen
            raise ValueError("Not plant was skipped but load couldn't be committed.")

    # 5. Compile Final Production Plan

    for item in merit_list:
        production_plan.append(ProductionPlanItem(
            name=item["plant"].name, 
            p=item["production"]
        ))

    return production_plan
